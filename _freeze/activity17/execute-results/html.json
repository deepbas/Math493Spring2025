{
  "hash": "267cb4aad560011297c3eb37833b3886",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: \"Activity17\"\nformat: live-html\nengine: knitr\ntoc: true\nwebr:\n  packages:\n    - dplyr\n    - ggplot2\n    - fpp3\n    - patchwork\n    - tsibbledata\n    - urca\n    - astsa\n    - gridExtra\n    - vars\nwarning: false\nmessage: false\n---\n\n::: {.cell}\n\n:::\n\n\n::: {.cell}\n\n:::\n\n\n## Review of concepts and applications covered so far!\n\n1. Exploratory Data Analysis and Preprocessing\n\n- *Visualization:* Plot the raw time‐series data to inspect for trends, seasonality, and irregular fluctuations (including rolling means/variances).\n- *Transformations:* Apply appropriate transformations (e.g. logarithmic or Box–Cox) to stabilize variance.\n\n::: {.cell}\n```{webr}\n# Simulate a multivariate time series dataset with trend, seasonality, and noise\nset.seed(42)\nn <- 200\ndates <- seq.Date(as.Date(\"2021-01-01\"), by = \"day\", length.out = n)\ntrend1 <- seq(1, n) / 10\ntrend2 <- seq(1, n) / 12\nseason1 <- sin(2 * pi * (1:n) / 12)\nseason2 <- cos(2 * pi * (1:n) / 12)\nnoise1 <- rnorm(n, 0, 1)\nnoise2 <- rnorm(n, 0, 1)\ndata_df <- data.frame(\n  date = dates,\n  series1 = 50 + trend1 + season1 + noise1,\n  series2 = 30 + trend2 + season2 + noise2\n)\n\n# Convert to tsibble \nts_data <- as_tsibble(data_df, index = date)\n\n# Plot raw data for series1 and series2\np1 <- autoplot(ts_data, series1) +\n  labs(title = \"Raw Data: Series1\", y = \"Series1\")\np2 <- autoplot(ts_data, series2) +\n  labs(title = \"Raw Data: Series2\", y = \"Series2\")\ngrid.arrange(p1, p2, ncol = 2)\n```\n:::\n\n\n2. Decomposition & Stationarity Testing\n\n- *Decomposition:* Use methods like STL to break the series into trend, seasonal, and remainder components.\n- *Detrending/Deseasonalizing:* Remove or model the trend and seasonal components so that the residual approximates white noise.\nStationarity Tests: Apply tests (e.g., ADF, KPSS) and difference the series as needed to achieve stationarity.\n\n::: {.cell}\n```{webr}\n# Decompose series1 using STL (additive model)\nstl_decomp <- ts_data %>%\n  model(STL(series1 ~ season(window = \"periodic\"))) %>%\n  components()\n\nautoplot(stl_decomp) +\n  labs(title = \"STL Decomposition of Series1\")\n\n# Inspect the remainder component as a proxy for stationarity\nautoplot(stl_decomp, remainder) +\n  labs(title = \"Remainder (Noise) Component of Series1\")\n```\n:::\n\n\n3. Model Identification & Fitting\n\n- *Lag Selection:* Determine the optimal lag length (using criteria such as AIC or BIC) for an autoregressive or VAR model.\n- *Dynamic Modeling:* Fit an autoregressive model (or a VAR for multivariate data) on the stationary series.\nGranger Causality Testing: Within the VAR framework, test whether past values of one variable significantly improve the prediction of another.\n\n::: {.cell}\n```{webr}\n# For VAR, we need a multivariate time series object.\nvar_data <- ts_data %>% as_tibble() %>% dplyr::select(series1, series2)\n             \n\n# Lag Selection: Use VARselect to determine optimal lag order \nlag_sel <- VARselect(var_data, lag.max = 10, type = \"const\")\nprint(lag_sel$selection)\n\n# Fit the VAR model with the chosen lag order\nvar_model <- VAR(var_data, p = 10, type = \"const\")\nsummary(var_model)\n```\n:::\n\n\n\n4. Impulse Response Analysis\n\n- *IRF Computation:* After estimating the VAR, compute impulse response functions to trace how shocks to one variable affect the system over time.\n- *Interpretation:* Use IRFs to quantify the duration and magnitude of shock effects, complementing the Granger causality findings.\n\n::: {.cell}\n```{webr}\n# Compute the impulse response function for the effect of a shock in series1 on series2 (12 periods ahead)\nirf_result <- irf(var_model, impulse = \"series1\", response = \"series2\",\n                  n.ahead = 18, boot = TRUE)\nplot(irf_result)\n```\n:::\n\n\n5. Diagnostics & Forecasting\n\n- *Residual Analysis:* Check that the model’s residuals resemble white noise (e.g., via Ljung–Box tests) to validate the model fit.\nForecasting: Employ the fitted model to forecast future values, reintroducing trend and seasonal components as needed.\n\n\n::: {.cell}\n```{webr}\n# Diagnostics: Test for serial correlation in the VAR residuals (using 12 lags)\nserial_test <- serial.test(var_model, lags.pt = 12, type = \"PT.adjusted\")\n\n# Forecasting: Forecast the next 12 periods using the VAR model\nvar_forecast <- predict(var_model, n.ahead = 12)\nplot(var_forecast)\n```\n:::\n\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}